/*
Package aur provides functions and types for interacting with Arch Linux's AUR.
*/
package aur

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
)

// AURHost is the HTTP scheme and domain of the AUR.
const AURHost = "https://aur.archlinux.org"

// AURInfoPath is the URL path of the AUR information endpoint.
const aurInfoPath = "/rpc/v5/info"

// AURSearchPath is the URL path of the AUR search endpoint.
const aurSearchPath = "/rpc/v5/search"

// A SearchType is the kind of AUR search to perform.
// It determines which fields of packages a search term will match against.
type SearchType int

const (
	NameDesc     SearchType = iota // match name or description
	Name                           // match package names only
	Maintainer                     // match package maintainers
	Depends                        // match package dependencies
	MakeDepends                    // match dependencies required to build a package
	OptDepends                     // match optional dependencies of a package
	CheckDepends                   // match dependencies required to check a package
)

var queryKeys = map[SearchType]string{
	NameDesc:     "name-desc",
	Name:         "name",
	Maintainer:   "maintainer",
	Depends:      "depends",
	MakeDepends:  "makedepends",
	OptDepends:   "optdepends",
	CheckDepends: "checkdepends",
}

/*
Search queries the AUR for any packages matching the keyword.
Searches can be performed against any package detail described as a SearchType in this package.
The results, if any, do not include details about dependencies, licensing, etc.
Any Go-generated or AUR error is returned in err.
*/
func Search(keyword string, by SearchType) (results []aurPackage, err error) {
	query := make(url.Values)
	query.Set("by", queryKeys[by])

	switch r, err := makeRequest(query.Encode(), aurSearchPath, keyword); {
	case err != nil:
		return nil, err
	case r.Error != "":
		return nil, fmt.Errorf("AUR error: %s", r.Error)
	default:
		results = r.Results
	}

	return
}

/*
Info queries the AUR for detailed information about the requested packages.
The results will include details about licenses, package relationships, etc.
If the request generates a Go error, or the API returns an error, it is available in err.
*/
func Info(packages []string) (results []aurPackage, err error) {
	if len(packages) < 1 {
		return nil, fmt.Errorf("no packages specified; nothing to do")
	}
	// the query string needs escaped brackets, but not the equal sign
	queryString := fmt.Sprintf("arg%%5B%%5D=%s", packages[0])
	if len(packages) > 1 {
		for _, pkg := range packages[1:] {
			queryString = fmt.Sprintf("%s&arg%%5B%%5D=%s", queryString, pkg)
		}
	}

	switch r, err := makeRequest(queryString, aurInfoPath); {
	case err != nil:
		return nil, err
	case r.Error != "":
		return nil, fmt.Errorf("AUR error: %s", r.Error)
	default:
		results = r.Results
	}

	return
}

/*
makeRequest handles the actual HTTP request to the AUR API.
The query should be an already-encoded string.
Any strings passed as parts of the endpoint will be appropriately joined.
This function only checks for errors generated by Go functions;
callers are responsible for checking the AUR response for an error.
*/
func makeRequest(query string, endpoint ...string) (response *result, err error) {
	target, err := url.Parse(AURHost)
	if err != nil {
		return nil, fmt.Errorf("failed to parse AUR base URL: %w", err)
	}
	target = target.JoinPath(endpoint...)
	target.RawQuery = query

	r, err := http.Get(target.String())
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}
	defer r.Body.Close()
	b, err := io.ReadAll(r.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}
	response = new(result)
	if err = json.Unmarshal(b, response); err != nil {
		return nil, fmt.Errorf("failed to unmarshal JSON response: %w", err)
	}

	return
}

/*
DownloadSnapshot retrieves a snapshot of the package with name and saves it locally.
The output file is saved in a subdirectory created in the OS's temporary directory.
If the HTTP and file operations are successful the file's absolute path is returned in filepath.
Any error encountered is returned in err.
*/
func DownloadSnapshot(name string) (filepath string, err error) {
	// retrieve the package info from the AUR
	results, err := Info([]string{name})
	if err != nil {
		return "", err
	}
	if len(results) != 1 {
		return "", fmt.Errorf("no package with matching name '%s' found", name)
	}
	aurPackage := results[0]

	// create a temporary file and get its handle
	f, err := os.CreateTemp("", aurPackage.Name+"-*.tar.gz")
	if err != nil {
		return "", fmt.Errorf("failed to open temporary file for writing: %w", err)
	}
	defer f.Close()

	// make the HTTP request for the snapshot and save it to the file
	response, err := http.Get(AURHost + aurPackage.URLPath)
	if err != nil {
		return "", fmt.Errorf("failed to make http request: %w", err)
	}
	defer response.Body.Close()
	if _, err = f.ReadFrom(response.Body); err != nil {
		return "", fmt.Errorf("failed to save response to file: %w", err)
	}

	return f.Name(), nil
}
